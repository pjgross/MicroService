<!DOCTYPE html>
<html>
    <head>
        <title>Peter gross : 3) 12 Factor App - Design principles from SOA</title>
        <link rel="stylesheet" href="styles/site.css" type="text/css" />
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    </head>

    <body class="theme-default aui-theme-default">
        <div id="page">
            <div id="main" class="aui-page-panel">
                <div id="main-header">
                    <div id="breadcrumb-section">
                        <ol id="breadcrumbs">
                            <li class="first">
                                <span><a href="index.html">Peter gross</a></span>
                            </li>
                                                    <li>
                                <span><a href="MicroService-Learning-Journey---Story-so-far_956991180.html">MicroService Learning Journey - Story so far</a></span>
                            </li>
                                                    <li>
                                <span><a href="960542694.html">1) Introduction</a></span>
                            </li>
                                                </ol>
                    </div>
                    <h1 id="title-heading" class="pagetitle">
                                                <span id="title-text">
                            Peter gross : 3) 12 Factor App - Design principles from SOA
                        </span>
                    </h1>
                </div>

                <div id="content" class="view">
                    <div class="page-metadata">
                        
        
    
        
    
        
        
            Created by <span class='author'> Peter Gross</span>, last modified on Sep 15, 2020
                        </div>
                    <div id="main-content" class="wiki-content group">
                    <div class="contentLayout2">
<div class="columnLayout three-with-sidebars" data-layout="three-with-sidebars">
<div class="cell sidebars" data-type="sidebars">
<div class="innerCell">
<p><br/></p></div>
</div>
<div class="cell normal" data-type="normal">
<div class="innerCell">
<p>All of the articles i have read and courses I have done use the 12 Factor App principles for their development.</p><p><br/></p><p>Here are the base principles it says to follow:</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-1.Codebase">1. Codebase</h3><blockquote><p>One codebase tracked in revision control, many deploys</p></blockquote><p>This is pretty fundamental, yet sometimes you can see people breaking this principle. You should not create two different repositories when all you need to do is different setup for production. Of course you can have multiple version of the app deployed, just make sure that their share the codebase. If you are wondering how to deal with multiple versions in a single codebase, I recommend having a look at<span> </span><a class="external-link" href="https://danielkummer.github.io/git-flow-cheatsheet/" rel="nofollow" style="text-decoration: inherit;">git-flow</a>.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-2.Dependencies">2. Dependencies</h3><blockquote><p>Explicitly declare and isolate dependencies</p></blockquote><p>Thinking about dependencies usually does not go beyond the dependant libraries. As long as you use a standard build tool (npm, yarn, maven, gradle, NuGet) you have the basics covered. It is more difficult when it comes to managing dependencies- required database connections, services, etc. Here it may be easier to look for help from tools such as<span> <a class="external-link" href="https://www.ansible.com/" rel="nofollow">ansible</a></span><span> </span>and<span> </span><a class="external-link" href="https://kubernetes.io/" rel="nofollow" style="text-decoration: inherit;">kubernetes</a>. It is really beneficial for the speed of development and on-boarding when all that is needed doing is checking out the repository from the source control and running the build.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-3.Config">3. Config</h3><blockquote><p>Store config in the environment</p></blockquote><p>It is very easy to make a mistake when dealing with the configuration in microservices. In the beginning it is quite simple to just create a few configuration files and load them depending on which environment the service is being executed. While this seems like a good idea at first, as the number of services and environments grow, this can quickly go out of hand- you can think of it as an O(n^2) solution to the configuration problem.</p><p>The real solution (O(n)) is keeping the configuration in environments. Adding new services is then trivial as you don’t need to update all the config in this new service and keep them all manually in sync. This problem is much more common in places where developers and operations are two separate strictly separate groups. Lack of communication, or control leads to the sub-par solution. This can be fixed in your company by implementing more DevOps culture.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-4.Backingservices">4. Backing services</h3><blockquote><p>Treat backing services as attached resources</p></blockquote><p>This is a common practice already and not something that professional developers get wrong often. The idea is that your services should be easily interchangeable. If you are referencing them as simple urls with login credentials there is no reason why they shouldn’t be. This will ensure good portability and helps maintain your system.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-5.Build,release,run">5. Build, release, run</h3><blockquote><p>Strictly separate build and run stages</p></blockquote><p>Before thinking about it, it is worth to note what each of these mean in the context of the Twelve-Factor App:</p><ul><li>Build - converting code repo into an executable bundle known as the build.</li><li>Release - getting the build and combining it with a config on a certain environment- ready to run. This is also often referred to as deployment.</li><li>Run - starting the app in the deployment</li></ul><p>Separation of these processes is important to make sure that automation and maintaining the system will be as easy as possible. This separation is expected by many modern tools as well.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-6.Processes">6. Processes</h3><blockquote><p>Execute the app as one or more stateless processes</p></blockquote><p>This is another factor, that is at the core of microservices architecture. The idea of stateless services, that can be easily scaled by deploying more of them is part of the definition what a microservices are. You should not be introducing state into your services (that should leave in database or<span> </span><a class="external-link" href="https://memcached.org/" rel="nofollow" style="text-decoration: inherit;">memcached</a>,<span> </span><a class="external-link" href="https://redis.io/" rel="nofollow" style="text-decoration: inherit;">redis</a><span> </span>- for the session information). Simple, but a crucial consideration when designing your architecture.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-7.Portbinding">7. Port binding</h3><blockquote><p>Export services via port binding</p></blockquote><p>This is quite simple- make sure that your service is visible to others via port binding (if you need it visible at all, possibly it just consumer from a queue). If you built a service, make sure that other services can treat this as a resource if they wish.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-8.Concurrency">8. Concurrency</h3><blockquote><p>Scale out via the process model</p></blockquote><p>As the headline says- this is all about scalability. Tools such as<span> </span><a class="external-link" href="https://kubernetes.io/" rel="nofollow" style="text-decoration: inherit;">kubernetes</a><span> </span>can really help you here. The idea is that, as you need to scale, you should be deploying more copies of your application (processes) rather than trying to make your application larger (by running a single instance on the most powerful machine available). Practice has shown that this is simpler and more resilient approach to do it. Some may argue that the word micro in the microservices hints at this as well (beside the services being small code-wise).</p><p>There is a misconception that modern developers don’t need to worry about low level threading considerations. This is wrong, as most services will have multithreading introduced via multiple request being handled simultaneously.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-9.Disposability">9. Disposability</h3><blockquote><p>Maximize robustness with fast startup and graceful shutdown</p></blockquote><p>Fast startup is based on our ideas about scalability and the fact that we decided on microservices. It is important that they can go up and down quickly. Without this, automatic scaling and ease of deployment, development- are being diminished. This is one of the factors, where if we don’t get it exactly right- the system will still work. However, the goal here is to achieve resounding success, not just an acceptable compromise.</p><p>Graceful shutdowns are arguably more important, as this is about leaving the system in a correct state. The port that was used should be freed so that the new server can be started, any unfinished task should be returned to the queue etc.</p><p>One last thing… Crashes also need to be handled. These will be the responsibility of the whole system rather than just the service- just don’t forget about it.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-10.Dev/prodparity">10. Dev/prod parity</h3><blockquote><p>Keep development, staging, and production as similar as possible</p></blockquote><p>The differences between dev and prod can be significantly larger than people realise. It goes beyond the configuration and data, but also includes:</p><blockquote><ul><li>The time gap: A developer may work on code that takes days, weeks, or even months to go into production.</li><li>The personnel gap: Developers write code, ops engineers deploy it.</li><li>The tools gap: Developers may be using a stack like Nginx, SQLite, and OS X, while the production deploy uses Apache, MySQL, and Linux.</li></ul></blockquote><p>In fact this is explained in excellent fashion on the original<span> </span><a class="external-link" href="https://12factor.net/dev-prod-parity" rel="nofollow" style="text-decoration: inherit;">Twelve-Factor App Section</a>.</p><p>The differences when it comes to microservices? It may be even more challenging to achieve this parity than it is with other types of architecture. This is one of the reasons why doing microservices is seen as a challenge. The good news- if you managed to achieve the previous 10 factors, this one should be significantly easier! The common theme reappearing here is the need for developer to work closely with operations. The devops culture is one of the requirements for truly successful microservices.</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-11.Logs">11. Logs</h3><blockquote><p>Treat logs as event streams</p></blockquote><p>This factor more than any other is about excellence rather than adequacy. Success is possible without logs as event streams, but you will be missing on a dramatic upside here. This is one of the easier things to do, but the pay-off can be significant. Bringing<span> </span><a class="external-link" href="https://www.splunk.com/" rel="nofollow" style="text-decoration: inherit;">Splunk</a><span> </span>or<span> </span><a class="external-link" href="https://www.elastic.co/products/logstash" rel="nofollow" style="text-decoration: inherit;">Logstash/ELK Stack</a><span> </span>to help with your logs, can bring dramatic gains. My experience with Splunk changed QA debugging from a dreaded activity (with many microservices in place) to something that I actually enjoyed!</p><p>Trends, alerts, heuristic, monitoring- all of these can come from well design logs, treated as event streams and captured by one of these technologies. Don’t miss out on that!</p><h3 id="id-3)12FactorApp-DesignprinciplesfromSOA-12.Adminprocesses">12. Admin processes</h3><blockquote><p>Run admin/management tasks as one-off processes</p></blockquote><p>This is more about managing your app rather than developing services, but it is still important. Admin tasks should be run from the relevant servers- possibly production servers. This is easiest done by shipping admin code with application code to provide these capabilities. The tools should be there even if they are not part of the standard execution of the service. What we try to do here is to isolate dependencies, as Admin processes and tools required to carry them out are dependencies as well.</p></div>
</div>
<div class="cell sidebars" data-type="sidebars">
<div class="innerCell">
<p><br/></p></div>
</div>
</div>
</div>
                    </div>

                    
                                                      
                </div>             </div> 
            <div id="footer" role="contentinfo">
                <section class="footer-body">
                    <p>Document generated by Confluence on Oct 17, 2020 17:15</p>
                    <div id="footer-logo"><a href="http://www.atlassian.com/">Atlassian</a></div>
                </section>
            </div>
        </div>     </body>
</html>
